<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Let Down - Radiohead | Scene Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000000;
            font-family: 'Courier New', Courier, monospace;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #canvas-container canvas {
            display: block;
        }

        /* Film Grain Overlay */
        #grain-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 3;
            pointer-events: none;
            opacity: 0.15;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            mix-blend-mode: overlay;
            transition: opacity 0.5s ease;
        }

        #grain-overlay.active {
            opacity: 0.15;
            animation: grainShift 0.1s steps(2) infinite;
        }

        @keyframes grainShift {
            0% {
                transform: translate(0, 0);
            }

            50% {
                transform: translate(-1%, -1%);
            }

            100% {
                transform: translate(1%, 1%);
            }
        }

        /* Typography Container */
        #lyrics-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: none;
        }

        #lyric-text {
            font-family: 'Courier New', Courier, monospace;
            font-size: clamp(1.5rem, 4vw, 3rem);
            font-weight: bold;
            color: #ffffff;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            max-width: 80vw;
            text-shadow:
                0 0 10px #ffffff,
                0 0 20px #ffffff,
                0 0 40px #aaccff,
                0 0 80px #aaccff;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #lyric-text.visible {
            opacity: 1;
            animation: textEntrance 0.8s ease-out forwards;
        }

        @keyframes textEntrance {
            0% {
                opacity: 0;
                transform: translateY(20px) scale(0.9);
                filter: blur(10px);
            }

            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
                filter: blur(0);
            }
        }

        /* Glitch Effect */
        #lyric-text.glitch {
            animation: glitch 0.15s infinite;
        }

        @keyframes glitch {
            0% {
                text-shadow: -3px 0 #ff0000, 3px 0 #00ffff, 0 0 10px #ffffff;
                transform: translate(0);
            }

            25% {
                text-shadow: 3px 0 #ff0000, -3px 0 #00ffff, 0 0 10px #ffffff;
                transform: translate(-3px, 2px);
            }

            50% {
                text-shadow: -3px 0 #ff0000, 3px 0 #00ffff, 0 0 10px #ffffff;
                transform: translate(3px, -2px);
            }

            75% {
                text-shadow: 3px 0 #ff0000, -3px 0 #00ffff, 0 0 10px #ffffff;
                transform: translate(-2px, 3px);
            }

            100% {
                text-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff;
                transform: translate(0);
            }
        }

        /* Flash Overlay */
        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #ffffff;
            opacity: 0;
            z-index: 5;
            pointer-events: none;
            transition: opacity 0.1s ease;
        }

        /* Start Overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            cursor: pointer;
        }

        #start-overlay.hidden {
            display: none;
        }

        .start-content {
            text-align: center;
            color: #ffffff;
        }

        .start-content h1 {
            font-family: 'Courier New', Courier, monospace;
            font-size: clamp(2rem, 8vw, 5rem);
            font-weight: bold;
            letter-spacing: 0.3em;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px #ffffff;
        }

        .start-content .artist {
            font-size: 1.2rem;
            letter-spacing: 0.2em;
            opacity: 0.5;
            margin-bottom: 0.5rem;
        }

        .start-content .credit {
            font-size: 0.8rem;
            letter-spacing: 0.15em;
            opacity: 0.35;
            margin-bottom: 2.5rem;
            font-style: italic;
        }

        .start-content .instruction {
            font-size: 0.9rem;
            opacity: 0.7;
            animation: blink 1.5s ease-in-out infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 0.3;
            }

            50% {
                opacity: 1;
            }
        }

        .start-content .note {
            font-size: 0.7rem;
            opacity: 0.3;
            margin-top: 2rem;
        }

        /* Scene indicator */
        #scene-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            z-index: 50;
        }

        /* ========================================
           CAPCUT OLD FILM MODE - 1920s Horror Look
           ======================================== */
        body.capcut-mode {
            background: #1a1a1a;
        }

        body.capcut-mode #canvas-container canvas {
            filter: invert(1) grayscale(1) contrast(3.5) brightness(1.1);
        }

        body.capcut-mode #lyric-text {
            color: #000000;
            text-shadow:
                0 0 10px #000000,
                0 0 20px #333333,
                0 0 40px #555555;
        }

        body.capcut-mode #grain-overlay {
            opacity: 0.5;
            mix-blend-mode: multiply;
        }

        /* Film Scratches Overlay */
        #scratch-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 4;
            pointer-events: none;
            opacity: 0;
            background: repeating-linear-gradient(90deg,
                    transparent 0px,
                    transparent 3px,
                    rgba(255, 255, 255, 0.03) 3px,
                    rgba(255, 255, 255, 0.03) 4px,
                    transparent 4px,
                    transparent 20px,
                    rgba(0, 0, 0, 0.05) 20px,
                    rgba(0, 0, 0, 0.05) 21px);
            mix-blend-mode: overlay;
            transition: opacity 0.5s ease;
        }

        body.capcut-mode #scratch-overlay {
            opacity: 1;
            animation: scratchFlicker 0.08s steps(3) infinite, scratchMove 0.5s linear infinite;
        }

        @keyframes scratchFlicker {
            0% {
                opacity: 0.6;
            }

            33% {
                opacity: 0.9;
            }

            66% {
                opacity: 0.5;
            }

            100% {
                opacity: 0.8;
            }
        }

        @keyframes scratchMove {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(30px);
            }
        }

        /* Vignette for old film look */
        body.capcut-mode::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0, 0, 0, 0.6) 100%);
            pointer-events: none;
            z-index: 6;
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="grain-overlay"></div>
    <div id="scratch-overlay"></div>
    <div id="flash-overlay"></div>

    <div id="lyrics-container">
        <div id="lyric-text"></div>
    </div>

    <div id="start-overlay">
        <div class="start-content">
            <h1>LET DOWN</h1>
            <p class="artist">RADIOHEAD</p>
            <p class="credit">made by Zai</p>
            <p class="instruction">[ CLICK TO BEGIN ]</p>
            <p class="note">Scene-Based Visual Experience</p>
        </div>
    </div>

    <div id="scene-indicator"></div>

    <!-- Audio Player - Place your MP3 file in the 'audio' folder as 'letdown.mp3' -->
    <audio id="audio-player" preload="auto">
        <source src="audio/letdown.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    <script>
        // ========================================
        // LET DOWN - Scene-Based Visual Storytelling
        // With Phantom Runner Intro
        // ========================================

        // Scene Types
        const SCENES = {
            RUNNER: 'runner',      // New! Phantom Runner intro
            COLLAPSE: 'collapse',
            ASCENT: 'ascent',      // NEW! Bouncing back - particles reverse upward
            WINGS: 'wings',
            HYSTERICAL: 'hysterical',
            VOID: 'void'
        };

        // RGB Shift Shader
        const RGBShiftShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'amount': { value: 0.0 },
                'angle': { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float amount;
                uniform float angle;
                varying vec2 vUv;
                
                void main() {
                    vec2 offset = amount * vec2(cos(angle), sin(angle));
                    vec4 cr = texture2D(tDiffuse, vUv + offset);
                    vec4 cga = texture2D(tDiffuse, vUv);
                    vec4 cb = texture2D(tDiffuse, vUv - offset);
                    gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);
                }
            `
        };

        // B&W Desaturation Shader
        const GrayscaleShader = {
            uniforms: {
                'tDiffuse': { value: null },
                'amount': { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float amount;
                varying vec2 vUv;
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                    vec3 grayscale = vec3(gray);
                    gl_FragColor = vec4(mix(color.rgb, grayscale, amount), color.a);
                }
            `
        };

        // ========================================
        // Configuration
        // ========================================
        const CONFIG = {
            particleCount: 25000,  // Increased for denser wings
            runnerParticleCount: 2500,  // Denser cluster for solid black phantom
            tunnelParticleCount: 8000, // Dense tunnel streaks for speed lines
            gravity: 50,
            floorY: -30,
            bounceCoefficient: 0.5,
            wingSpan: 25,
            wingHeight: 15,
            trailOpacity: 0.03,  // For afterimage effect - ghostly/blurry look
            zoomBlurScale: 1.003  // Zoom blur for runner scene
        };

        // ========================================
        // Global State
        // ========================================
        let scene, camera, renderer, composer;
        let particleGeometry, particleMaterial, particles;
        let tunnelGeometry, tunnelMaterial, tunnelParticles;
        let runnerGeometry, runnerMaterial, runnerParticles;
        let bloomPass, rgbShiftPass, grayscalePass;
        let clock;
        let isRunning = false;
        let currentScene = SCENES.RUNNER;
        let sceneStartTime = 0;

        // Particle data arrays
        let positions, velocities, targetPositions, originalPositions;
        let particlePhases;

        // Tunnel particles
        let tunnelPositions, tunnelVelocities;

        // Runner phantom
        let runnerPositions, runnerBasePositions;

        // Ascent scene - Comet orb
        let cometOrb, cometOrbY = -100;
        let ascentInitialized = false;

        // Camera state
        let cameraShake = 0;
        let targetCameraY = 0;
        let targetCameraRotationX = 0;

        // Trail effect state
        let trailsEnabled = true;
        let useGrayscale = true;

        // DOM Elements
        const lyricElement = document.getElementById('lyric-text');
        const flashOverlay = document.getElementById('flash-overlay');
        const startOverlay = document.getElementById('start-overlay');
        const sceneIndicator = document.getElementById('scene-indicator');
        const grainOverlay = document.getElementById('grain-overlay');
        const audioPlayer = document.getElementById('audio-player');

        // ========================================
        // Updated Lyric Sequence
        // ========================================
        const LYRIC_SEQUENCE = [
            // SCENE 1: RUNNER (Intro)
            { time: 0, text: "", scene: SCENES.RUNNER },

            // LINE 1: Start slightly earlier to catch the breath
            { time: 3.0, text: "you know..." },

            // LINE 2: Let Line 1 breathe longer
            { time: 6.2, text: "you know where you are with" },

            // LINE 3: The Repetition - holds for 3.5s until drop
            { time: 9.5, text: "you know where you are with" },

            // SCENE 2: COLLAPSE (The Drop - anchor point)
            { time: 14.0, text: "FLOOR COLLAPSES", scene: SCENES.COLLAPSE, flash: true, intense: true },
            { time: 16.5, text: "floating" },

            // SCENE 3: ASCENT (The Orb)
            { time: 20.5, text: "bouncing back", scene: SCENES.ASCENT },
            { time: 22.5, text: "and one day" },

            // SCENE 4: WINGS
            { time: 26.0, text: "I AM GONNA GROW WINGS", scene: SCENES.WINGS, flash: true },

            // SCENE 5: HYSTERICAL
            { time: 30.5, text: "a chemical reaction" },
            { time: 34.5, text: "HYSTERICAL AND USELESS", scene: SCENES.HYSTERICAL, glitch: true },
            { time: 40.5, text: "hysterical and useless", glitch: true },

            // Outro
            { time: 55.0, text: "", scene: SCENES.VOID }
        ];

        // ========================================
        // Initialization
        // ========================================
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 50;

            // Renderer with alpha for trail effects
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance",
                preserveDrawingBuffer: true  // For trail effect
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.autoClear = false;  // Manual clearing for trails
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post-processing
            setupPostProcessing();

            // Create all particle systems
            createTunnelParticles();
            createRunnerParticles();
            createMainParticles();
            createCometOrb();

            // Clock
            clock = new THREE.Clock();

            // Events
            window.addEventListener('resize', onWindowResize);
            startOverlay.addEventListener('click', startExperience);

            // Start render loop
            animate();

            console.log('Scene Visualizer with Phantom Runner Ready!');
        }

        // ========================================
        // Post-Processing
        // ========================================
        function setupPostProcessing() {
            composer = new THREE.EffectComposer(renderer);

            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            // Grayscale pass (for B&W intro)
            grayscalePass = new THREE.ShaderPass(GrayscaleShader);
            grayscalePass.uniforms['amount'].value = 1.0;
            composer.addPass(grayscalePass);

            // Bloom
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.8, 0.5, 0.85
            );
            composer.addPass(bloomPass);

            // RGB Shift
            rgbShiftPass = new THREE.ShaderPass(RGBShiftShader);
            rgbShiftPass.uniforms['amount'].value = 0;
            composer.addPass(rgbShiftPass);
        }

        // ========================================
        // Tunnel Particles (Speed Lines)
        // ========================================
        function createTunnelParticles() {
            const count = CONFIG.tunnelParticleCount;

            tunnelGeometry = new THREE.BufferGeometry();
            tunnelPositions = new Float32Array(count * 3);
            tunnelVelocities = new Float32Array(count);

            const colors = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Cylindrical tunnel distribution
                const theta = Math.random() * Math.PI * 2;
                const radius = 20 + Math.random() * 80;

                tunnelPositions[i3] = Math.cos(theta) * radius;
                tunnelPositions[i3 + 1] = Math.sin(theta) * radius;
                tunnelPositions[i3 + 2] = Math.random() * -300 - 50;

                tunnelVelocities[i] = 150 + Math.random() * 100; // High speed!

                // White/gray colors
                const brightness = 0.5 + Math.random() * 0.5;
                colors[i3] = brightness;
                colors[i3 + 1] = brightness;
                colors[i3 + 2] = brightness;
            }

            tunnelGeometry.setAttribute('position', new THREE.BufferAttribute(tunnelPositions, 3));
            tunnelGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            tunnelMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uSize: { value: 1.5 }
                },
                vertexShader: `
                    attribute vec3 color;
                    uniform float uSize;
                    varying vec3 vColor;
                    varying float vDepth;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vDepth = -mvPosition.z;
                        
                        float sizeAtten = 60.0 / max(-mvPosition.z, 1.0);
                        gl_PointSize = uSize * sizeAtten;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vDepth;
                    
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        
                        // Soft circular falloff - key fix for round particles
                        float alpha = 1.0 - smoothstep(0.0, 0.4, dist);
                        alpha *= alpha; // Extra softness
                        if (alpha < 0.01) discard;
                        
                        float glow = clamp(100.0 / vDepth, 0.3, 1.0);
                        
                        gl_FragColor = vec4(vColor * glow, alpha * glow * 0.8);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            tunnelParticles = new THREE.Points(tunnelGeometry, tunnelMaterial);
            scene.add(tunnelParticles);
        }

        // ========================================
        // Runner Phantom Particles
        // ========================================
        function createRunnerParticles() {
            const count = CONFIG.runnerParticleCount;

            runnerGeometry = new THREE.BufferGeometry();
            runnerPositions = new Float32Array(count * 3);
            runnerBasePositions = new Float32Array(count * 3);

            const colors = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Create humanoid-ish shape using noise clusters
                // Torso (main mass)
                let x, y, z;
                const bodyPart = Math.random();

                if (bodyPart < 0.4) {
                    // Torso (3x scale)
                    x = (Math.random() - 0.5) * 9;
                    y = (Math.random() - 0.5) * 18;
                    z = (Math.random() - 0.5) * 6;
                } else if (bodyPart < 0.55) {
                    // Head (3x scale)
                    x = (Math.random() - 0.5) * 6;
                    y = 12 + (Math.random() - 0.5) * 6;
                    z = (Math.random() - 0.5) * 6;
                } else if (bodyPart < 0.75) {
                    // Left leg area (3x scale)
                    x = -3 + (Math.random() - 0.5) * 4.5;
                    y = -9 - Math.random() * 15;
                    z = (Math.random() - 0.5) * 6;
                } else if (bodyPart < 0.95) {
                    // Right leg area (3x scale)
                    x = 3 + (Math.random() - 0.5) * 4.5;
                    y = -9 - Math.random() * 15;
                    z = (Math.random() - 0.5) * 6;
                } else {
                    // Arms (3x scale)
                    x = (Math.random() > 0.5 ? 6 : -6) + (Math.random() - 0.5) * 3;
                    y = 3 + (Math.random() - 0.5) * 9;
                    z = (Math.random() - 0.5) * 6;
                }

                runnerPositions[i3] = x;
                runnerPositions[i3 + 1] = y;
                runnerPositions[i3 + 2] = z;

                runnerBasePositions[i3] = x;
                runnerBasePositions[i3 + 1] = y;
                runnerBasePositions[i3 + 2] = z;

                // High contrast white
                colors[i3] = 1.0;
                colors[i3 + 1] = 1.0;
                colors[i3 + 2] = 1.0;
            }

            runnerGeometry.setAttribute('position', new THREE.BufferAttribute(runnerPositions, 3));
            runnerGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            runnerMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uSize: { value: 6.0 }
                },
                vertexShader: `
                    attribute vec3 color;
                    uniform float uSize;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        float sizeAtten = 40.0 / max(-mvPosition.z, 1.0);
                        gl_PointSize = uSize * sizeAtten;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        
                        // Soft circular falloff for round, glowing particles
                        float alpha = 1.0 - smoothstep(0.0, 0.45, dist);
                        alpha *= alpha; // Smoother edges
                        if (alpha < 0.01) discard;
                        
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            runnerParticles = new THREE.Points(runnerGeometry, runnerMaterial);
            runnerParticles.position.z = 0;
            scene.add(runnerParticles);
        }

        // ========================================
        // Main Particle System (for non-runner scenes)
        // ========================================
        function createMainParticles() {
            const count = CONFIG.particleCount;

            particleGeometry = new THREE.BufferGeometry();

            positions = new Float32Array(count * 3);
            velocities = new Float32Array(count * 3);
            targetPositions = new Float32Array(count * 3);
            originalPositions = new Float32Array(count * 3);
            particlePhases = new Float32Array(count);

            const colors = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Start offscreen (will be populated when needed)
                positions[i3] = (Math.random() - 0.5) * 200;
                positions[i3 + 1] = (Math.random() - 0.5) * 200;
                positions[i3 + 2] = Math.random() * -200 - 50;

                originalPositions[i3] = positions[i3];
                originalPositions[i3 + 1] = positions[i3 + 1];
                originalPositions[i3 + 2] = positions[i3 + 2];

                velocities[i3] = 0;
                velocities[i3 + 1] = 0;
                velocities[i3 + 2] = 0;

                targetPositions[i3] = positions[i3];
                targetPositions[i3 + 1] = positions[i3 + 1];
                targetPositions[i3 + 2] = positions[i3 + 2];

                particlePhases[i] = Math.random() * Math.PI * 2;

                // Color variation
                const colorMix = Math.random();
                colors[i3] = 0.7 + colorMix * 0.3;
                colors[i3 + 1] = 0.8 + colorMix * 0.2;
                colors[i3 + 2] = 1.0;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uSize: { value: 1.5 }
                },
                vertexShader: `
                    attribute vec3 color;
                    uniform float uSize;
                    varying vec3 vColor;
                    varying float vDepth;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vDepth = -mvPosition.z;
                        
                        float sizeAtten = 80.0 / max(-mvPosition.z, 1.0);
                        gl_PointSize = uSize * sizeAtten;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vDepth;
                    
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = length(center);
                        
                        // Soft circular falloff - round glowing particles
                        float alpha = 1.0 - smoothstep(0.0, 0.4, dist);
                        alpha = alpha * alpha; // Extra softness for glow effect
                        if (alpha < 0.01) discard;
                        
                        float glow = clamp(80.0 / vDepth, 0.2, 1.0);
                        
                        gl_FragColor = vec4(vColor * glow, alpha * glow);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            particles.visible = false; // Hidden during runner scene
            scene.add(particles);
        }

        // ========================================
        // Comet Orb for Ascent Scene
        // ========================================
        function createCometOrb() {
            // Simple pure white orb - clean loading screen look
            cometOrb = new THREE.Group();

            // Core ONLY - pure white, solid, sharp
            const coreGeometry = new THREE.SphereGeometry(3, 16, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: false
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            cometOrb.add(core);

            // Position offscreen initially
            cometOrb.position.set(0, -100, 0);
            cometOrb.visible = false;

            scene.add(cometOrb);
        }

        // ========================================
        // Wing Shape Generator - EAGLE WING SILHOUETTE
        // Clear feather rows fanning outward
        // ========================================
        function generateWingTargets(time) {
            const count = CONFIG.particleCount;

            // EAGLE WING DIMENSIONS
            const wingSpan = 80;     // Width of each wing
            const wingHeight = 50;   // Height from top to bottom

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const side = i < count / 2 ? -1 : 1;

                // Create FEATHER ROWS that fan out like eagle wings
                const numFeathers = 20;  // Number of primary feathers
                const featherIndex = Math.random(); // Random position
                const featherNum = Math.floor(featherIndex * numFeathers);
                const posInFeather = Math.random(); // Position along feather

                // Feather angle: top feathers point UP-OUT, bottom feathers point DOWN-OUT
                // Creates the classic spread eagle silhouette
                const angleRange = Math.PI * 0.7; // Total spread angle
                const startAngle = Math.PI * 0.15; // Start slightly above horizontal
                const featherAngle = startAngle - (featherNum / numFeathers) * angleRange;

                // Feather length: longest in middle, shorter at edges (wing silhouette curve)
                const lengthProgress = featherNum / numFeathers;
                const lengthCurve = Math.sin(lengthProgress * Math.PI); // Peak at middle
                const featherLength = wingSpan * (0.4 + lengthCurve * 0.6);

                // Position along the feather (0 = base near body, 1 = tip)
                const dist = posInFeather * featherLength;

                // Base attachment point (where feather connects to wing bone)
                const baseX = 5 + lengthProgress * 8;
                const baseY = 15 - lengthProgress * 25;

                // Calculate feather position
                let x = baseX + Math.cos(featherAngle) * dist;
                let y = baseY + Math.sin(featherAngle) * dist;
                let z = -posInFeather * 8 - lengthProgress * 3; // Depth curve

                // Add slight variation for natural look (but not too much)
                x += (Math.random() - 0.5) * 1.5;
                y += (Math.random() - 0.5) * 1.5;
                z += (Math.random() - 0.5) * 1;

                // Apply side (left/right wing)
                x = x * side;

                // Subtle breathing animation (very gentle)
                const breathe = Math.sin(time * 0.8) * 0.5;
                y += breathe * posInFeather;

                targetPositions[i3] = x;
                targetPositions[i3 + 1] = y;
                targetPositions[i3 + 2] = z;
            }
        }

        // ========================================
        // Scene Update Functions
        // ========================================
        function updateRunner(deltaTime, time) {
            const runnerCount = CONFIG.runnerParticleCount;
            const tunnelCount = CONFIG.tunnelParticleCount;

            // Running gait animation (bob up and down)
            const runCycle = time * 8; // Running speed
            const bobHeight = Math.abs(Math.sin(runCycle)) * 1.5;
            const leanAngle = Math.sin(runCycle * 0.5) * 0.1;

            // Update runner particles with running motion
            for (let i = 0; i < runnerCount; i++) {
                const i3 = i * 3;

                // Base position + running animation
                const baseX = runnerBasePositions[i3];
                const baseY = runnerBasePositions[i3 + 1];
                const baseZ = runnerBasePositions[i3 + 2];

                // Add running bob
                runnerPositions[i3] = baseX + Math.sin(runCycle + baseY * 0.2) * 0.3;
                runnerPositions[i3 + 1] = baseY + bobHeight;
                runnerPositions[i3 + 2] = baseZ + Math.cos(runCycle * 2) * 0.2;

                // Leg motion (different phase for each leg)
                if (baseY < -3) {
                    const legPhase = baseX > 0 ? runCycle : runCycle + Math.PI;
                    runnerPositions[i3 + 1] += Math.sin(legPhase) * 2;
                    runnerPositions[i3 + 2] += Math.cos(legPhase) * 1.5;
                }

                // Arm swing
                if (Math.abs(baseX) > 1.5 && baseY > 0) {
                    const armPhase = baseX > 0 ? runCycle + Math.PI : runCycle;
                    runnerPositions[i3 + 2] += Math.sin(armPhase) * 2;
                }
            }

            runnerGeometry.attributes.position.needsUpdate = true;

            // Update tunnel particles (high speed toward camera)
            for (let i = 0; i < tunnelCount; i++) {
                const i3 = i * 3;

                tunnelPositions[i3 + 2] += tunnelVelocities[i] * deltaTime;

                // Reset when past camera
                if (tunnelPositions[i3 + 2] > 50) {
                    const theta = Math.random() * Math.PI * 2;
                    const radius = 20 + Math.random() * 80;
                    tunnelPositions[i3] = Math.cos(theta) * radius;
                    tunnelPositions[i3 + 1] = Math.sin(theta) * radius;
                    tunnelPositions[i3 + 2] = -300 - Math.random() * 100;
                }
            }

            tunnelGeometry.attributes.position.needsUpdate = true;

            // Post-processing: B&W with high bloom
            grayscalePass.uniforms['amount'].value = THREE.MathUtils.lerp(
                grayscalePass.uniforms['amount'].value, 1.0, deltaTime * 3
            );
            bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 1.0, deltaTime * 2);
            rgbShiftPass.uniforms['amount'].value *= 0.9;

            // Show grain
            grainOverlay.classList.add('active');

            // Visibility
            runnerParticles.visible = true;
            tunnelParticles.visible = true;
            particles.visible = false;
        }

        function updateCollapse(deltaTime, time) {
            const count = CONFIG.particleCount;
            const gravity = CONFIG.gravity;
            const floorY = CONFIG.floorY;
            const bounce = CONFIG.bounceCoefficient;

            // Transfer runner/tunnel particles to main system on first frame
            if (time - sceneStartTime < 0.1) {
                transferToMainParticles();
            }

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                velocities[i3 + 1] -= gravity * deltaTime;

                positions[i3] += velocities[i3] * deltaTime;
                positions[i3 + 1] += velocities[i3 + 1] * deltaTime;
                positions[i3 + 2] += velocities[i3 + 2] * deltaTime;

                if (positions[i3 + 1] < floorY) {
                    positions[i3 + 1] = floorY;
                    velocities[i3 + 1] = -velocities[i3 + 1] * bounce;
                    velocities[i3] += (Math.random() - 0.5) * 2;
                    velocities[i3 + 2] += (Math.random() - 0.5) * 2;
                    velocities[i3] *= 0.95;
                    velocities[i3 + 2] *= 0.95;
                }

                velocities[i3] *= 0.999;
                velocities[i3 + 2] *= 0.999;
            }

            particleGeometry.attributes.position.needsUpdate = true;

            // Transition to color
            grayscalePass.uniforms['amount'].value = THREE.MathUtils.lerp(
                grayscalePass.uniforms['amount'].value, 0.0, deltaTime * 2
            );
            bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 0.6, deltaTime * 2);
            rgbShiftPass.uniforms['amount'].value = THREE.MathUtils.lerp(
                rgbShiftPass.uniforms['amount'].value, 0.002, deltaTime * 3
            );

            // Hide grain
            grainOverlay.classList.remove('active');

            // Visibility
            runnerParticles.visible = false;
            tunnelParticles.visible = false;
            particles.visible = true;

            targetCameraY = -10;
            targetCameraRotationX = -0.15;
        }

        // ========================================
        // ASCENT Scene - Particles reverse, Comet rises
        // ========================================
        function updateAscent(deltaTime, time) {
            const count = CONFIG.particleCount;
            const sceneTime = time - sceneStartTime;

            // Initialize ascent on first frame
            if (!ascentInitialized) {
                // Reverse all particle velocities - shoot upward!
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;

                    // Reverse Y velocity and boost it upward
                    velocities[i3 + 1] = Math.abs(velocities[i3 + 1]) + 30 + Math.random() * 40;

                    // Add some horizontal spread
                    velocities[i3] = (Math.random() - 0.5) * 10;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 10;
                }

                // Reset comet
                cometOrbY = -60;
                cometOrb.visible = true;
                ascentInitialized = true;
                cameraShake = 0.5;
            }

            // Update particles - shooting upward
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Keep upward momentum with slight deceleration
                velocities[i3 + 1] *= 0.998;

                // Add slight upward gravity (reverse physics)
                velocities[i3 + 1] += 5 * deltaTime;

                positions[i3] += velocities[i3] * deltaTime;
                positions[i3 + 1] += velocities[i3 + 1] * deltaTime;
                positions[i3 + 2] += velocities[i3 + 2] * deltaTime;

                // Recycle particles that go too high
                if (positions[i3 + 1] > 150) {
                    positions[i3 + 1] = -50;
                    velocities[i3 + 1] = 30 + Math.random() * 30;
                    positions[i3] = (Math.random() - 0.5) * 50;
                    positions[i3 + 2] = (Math.random() - 0.5) * 50;
                }

                // Dampen horizontal
                velocities[i3] *= 0.99;
                velocities[i3 + 2] *= 0.99;
            }

            particleGeometry.attributes.position.needsUpdate = true;

            // Comet Orb - shooting upward fast
            const cometSpeed = 80 + sceneTime * 40; // Accelerating aggressively
            cometOrbY += cometSpeed * deltaTime;
            cometOrb.position.set(0, cometOrbY, 0);

            // AGGRESSIVE Squash & Stretch - Warp Drive Effect
            const maxTime = 0.5; // INSTANT warp effect (was 3.0)
            const t = Math.min(sceneTime / maxTime, 1.0); // Normalized 0-1

            // Scale X/Z (Thickness): Lerp from 1.0 down to 0.02 (needle thin)
            const squashXZ = THREE.MathUtils.lerp(1.0, 0.02, t);

            // Scale Y (Length): Lerp from 1.0 up to 30.0 (long laser streak)
            const stretchY = THREE.MathUtils.lerp(1.0, 30.0, t);

            // Apply with glitchy pulse
            const pulseScale = 1 + Math.sin(time * 25) * 0.08;
            cometOrb.scale.set(
                squashXZ * pulseScale,
                stretchY * pulseScale,
                squashXZ * pulseScale
            );

            // STRICT Camera Lock + G-Force Shake
            targetCameraY = cometOrbY;
            targetCameraRotationX = 0.2;
            cameraShake = 0.4; // Continuous shake for G-force vibration

            // Post-processing - CLEAN white orb, NO RGB split
            grayscalePass.uniforms['amount'].value = THREE.MathUtils.lerp(
                grayscalePass.uniforms['amount'].value, 0.0, deltaTime * 2
            );
            bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 1.0, deltaTime * 4);
            // DISABLE RGB shift - keep orb pure white!
            rgbShiftPass.uniforms['amount'].value = 0;

            grainOverlay.classList.remove('active');

            // Visibility
            runnerParticles.visible = false;
            tunnelParticles.visible = false;
            particles.visible = true;
            cometOrb.visible = true;
        }

        function updateWings(deltaTime, time) {
            const count = CONFIG.particleCount;
            const sceneTime = time - sceneStartTime;

            generateWingTargets(time);

            // INSTANT wing formation - no slow gather/grow
            // Wings appear immediately and directly
            const formSpeed = 8 * deltaTime; // Fast lerp to target

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Direct lerp to wing shape
                positions[i3] = THREE.MathUtils.lerp(positions[i3], targetPositions[i3], formSpeed);
                positions[i3 + 1] = THREE.MathUtils.lerp(positions[i3 + 1], targetPositions[i3 + 1], formSpeed);
                positions[i3 + 2] = THREE.MathUtils.lerp(positions[i3 + 2], targetPositions[i3 + 2], formSpeed);

                velocities[i3] = 0;
                velocities[i3 + 1] = 0;
                velocities[i3 + 2] = 0;
            }

            particleGeometry.attributes.position.needsUpdate = true;

            // Enhanced bloom for wing glow
            grayscalePass.uniforms['amount'].value = THREE.MathUtils.lerp(
                grayscalePass.uniforms['amount'].value, 0.0, deltaTime * 2
            );
            bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 2.0, deltaTime * 2);
            rgbShiftPass.uniforms['amount'].value *= 0.95;

            grainOverlay.classList.remove('active');

            runnerParticles.visible = false;
            tunnelParticles.visible = false;
            particles.visible = true;
            cometOrb.visible = false;

            targetCameraY = 0;
            targetCameraRotationX = 0;
        }

        function updateHysterical(deltaTime, time) {
            const count = CONFIG.particleCount;
            const sceneTime = time - sceneStartTime;

            if (sceneTime < 0.1) {
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;

                    const dx = positions[i3];
                    const dy = positions[i3 + 1];
                    const dz = positions[i3 + 2];
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) + 0.1;

                    const explosionForce = 80;
                    velocities[i3] = (dx / dist) * explosionForce + (Math.random() - 0.5) * 40;
                    velocities[i3 + 1] = (dy / dist) * explosionForce + (Math.random() - 0.5) * 40;
                    velocities[i3 + 2] = (dz / dist) * explosionForce + (Math.random() - 0.5) * 40;
                }
                cameraShake = 1.0;
            }

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                positions[i3] += velocities[i3] * deltaTime;
                positions[i3 + 1] += velocities[i3 + 1] * deltaTime;
                positions[i3 + 2] += velocities[i3 + 2] * deltaTime;

                positions[i3] += Math.sin(time * 20 + particlePhases[i]) * 0.5;
                positions[i3 + 1] += Math.cos(time * 25 + particlePhases[i]) * 0.5;

                velocities[i3] *= 0.995;
                velocities[i3 + 1] *= 0.995;
                velocities[i3 + 2] *= 0.995;

                if (Math.abs(positions[i3]) > 200) positions[i3] *= -0.5;
                if (Math.abs(positions[i3 + 1]) > 200) positions[i3 + 1] *= -0.5;
                if (Math.abs(positions[i3 + 2]) > 200) positions[i3 + 2] *= -0.5;
            }

            particleGeometry.attributes.position.needsUpdate = true;

            bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 2.5, deltaTime * 3);

            const targetRGB = 0.02 + Math.sin(time * 5) * 0.01;
            rgbShiftPass.uniforms['amount'].value = THREE.MathUtils.lerp(
                rgbShiftPass.uniforms['amount'].value, targetRGB, deltaTime * 5
            );
            rgbShiftPass.uniforms['angle'].value = time * 3;

            cameraShake = Math.max(cameraShake * 0.98, 0.3);

            // CHAOTIC CAMERA: Zoom in/out panic effect
            camera.position.z = 50 + Math.sin(time * 50) * 2;
            camera.fov = 75 + Math.random() * 5;
            camera.updateProjectionMatrix();
        }

        function updateVoid(deltaTime, time) {
            const count = CONFIG.particleCount;

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const phase = particlePhases[i];

                positions[i3] += Math.sin(time * 0.1 + phase) * 0.02;
                positions[i3 + 1] += Math.cos(time * 0.08 + phase * 1.3) * 0.02;
                positions[i3 + 2] += 0.05;

                if (positions[i3 + 2] > 50) {
                    positions[i3 + 2] = -100;
                    positions[i3] = (Math.random() - 0.5) * 150;
                    positions[i3 + 1] = (Math.random() - 0.5) * 150;
                }
            }

            particleGeometry.attributes.position.needsUpdate = true;

            bloomPass.strength = THREE.MathUtils.lerp(bloomPass.strength, 0.4, deltaTime * 2);
            rgbShiftPass.uniforms['amount'].value *= 0.9;
            grayscalePass.uniforms['amount'].value = THREE.MathUtils.lerp(
                grayscalePass.uniforms['amount'].value, 0.0, deltaTime * 2
            );

            grainOverlay.classList.remove('active');

            runnerParticles.visible = false;
            tunnelParticles.visible = false;
            particles.visible = true;

            targetCameraY = 0;
            targetCameraRotationX = 0;
        }

        // ========================================
        // Transfer particles from runner to main
        // ========================================
        function transferToMainParticles() {
            const count = CONFIG.particleCount;

            // Scatter particles from runner position
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Start from center area (where runner was)
                positions[i3] = (Math.random() - 0.5) * 30;
                positions[i3 + 1] = (Math.random() - 0.5) * 30 + 10;
                positions[i3 + 2] = (Math.random() - 0.5) * 30;

                // Give initial velocity
                velocities[i3] = (Math.random() - 0.5) * 10;
                velocities[i3 + 1] = Math.random() * 10;
                velocities[i3 + 2] = (Math.random() - 0.5) * 10;
            }

            particleGeometry.attributes.position.needsUpdate = true;
        }

        // ========================================
        // Scene Manager
        // ========================================
        function switchScene(newScene) {
            if (currentScene === newScene) return;

            console.log(`Switching to scene: ${newScene}`);

            // Toggle CapCut old film mode for RUNNER scene
            if (newScene === SCENES.RUNNER) {
                document.body.classList.add('capcut-mode');
            } else {
                document.body.classList.remove('capcut-mode');
                // Flash transition when entering COLLAPSE from RUNNER
                if (newScene === SCENES.COLLAPSE) {
                    flashScreen(1.0);
                }
            }

            // Reset scene-specific states
            if (newScene === SCENES.ASCENT) {
                ascentInitialized = false;
            }
            if (currentScene === SCENES.ASCENT && newScene !== SCENES.ASCENT) {
                cometOrb.visible = false;
            }

            currentScene = newScene;
            sceneStartTime = clock.getElapsedTime();

            sceneIndicator.textContent = `Scene: ${newScene.toUpperCase()}`;
        }
        // ========================================
        // Lyric Display
        // ========================================
        function showLyric(text, options = {}) {
            // 1. Reset: Remove class to stop animation
            lyricElement.classList.remove('visible');
            lyricElement.classList.remove('glitch');
            lyricElement.classList.remove('intense');

            // 2. Force Reflow: This forces the browser to realize the class is gone
            void lyricElement.offsetWidth;

            // 3. Set Text & Restart: Add class back to trigger animation from 0%
            lyricElement.textContent = text;
            lyricElement.classList.add('visible');

            // Apply specific effects
            if (options.glitch) {
                lyricElement.classList.add('glitch');
            }
            if (options.intense) {
                lyricElement.classList.add('intense');
            }
        }

        function hideLyric() {
            lyricElement.className = '';
            lyricElement.textContent = '';
        }

        function flashScreen(intensity = 0.8) {
            flashOverlay.style.opacity = intensity;
            setTimeout(() => {
                flashOverlay.style.opacity = 0;
            }, 50);
        }

        // ========================================
        // Execute Lyric Action
        // ========================================
        function executeLyric(lyric) {
            const { text, scene: newScene, flash, glitch } = lyric;

            if (newScene) {
                switchScene(newScene);
            }

            if (flash) {
                flashScreen(0.9);
            }

            if (text) {
                showLyric(text, { glitch });
            } else {
                hideLyric();
            }
        }

        // ========================================
        // Animation Loop
        // ========================================
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            // Trail effect: partial clear for afterimages
            if (currentScene === SCENES.RUNNER && isRunning) {
                // Create trail effect by not fully clearing
                renderer.autoClear = false;

                // Semi-transparent black overlay for trails (lower = longer smear)
                const trailCanvas = renderer.domElement;
                const ctx = trailCanvas.getContext('webgl2') || trailCanvas.getContext('webgl');
                if (ctx) {
                    // Use WebGL clear with alpha
                    renderer.setClearColor(0x000000, CONFIG.trailOpacity);
                    renderer.clear();

                    // Zoom blur effect - scale the canvas slightly for rush effect
                    const zoomScale = CONFIG.zoomBlurScale;
                    camera.fov = THREE.MathUtils.lerp(camera.fov, 75 + Math.sin(time * 3) * 2, deltaTime * 5);
                    camera.updateProjectionMatrix();
                }
            } else {
                renderer.autoClear = true;
                renderer.setClearColor(0x000000, 1);
                // Reset FOV when not in runner scene
                camera.fov = THREE.MathUtils.lerp(camera.fov, 75, deltaTime * 3);
                camera.updateProjectionMatrix();
            }

            if (isRunning) {
                switch (currentScene) {
                    case SCENES.RUNNER:
                        updateRunner(deltaTime, time);
                        break;
                    case SCENES.COLLAPSE:
                        updateCollapse(deltaTime, time);
                        break;
                    case SCENES.ASCENT:
                        updateAscent(deltaTime, time);
                        break;
                    case SCENES.WINGS:
                        updateWings(deltaTime, time);
                        break;
                    case SCENES.HYSTERICAL:
                        updateHysterical(deltaTime, time);
                        break;
                    case SCENES.VOID:
                        updateVoid(deltaTime, time);
                        break;
                }

                // Camera updates
                camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetCameraY, deltaTime * 2);
                camera.rotation.x = THREE.MathUtils.lerp(camera.rotation.x, targetCameraRotationX, deltaTime * 2);

                if (cameraShake > 0.01) {
                    camera.position.x = (Math.random() - 0.5) * cameraShake * 5;
                    camera.rotation.z = (Math.random() - 0.5) * cameraShake * 0.1;
                    cameraShake *= 0.95;
                } else {
                    camera.position.x = THREE.MathUtils.lerp(camera.position.x, 0, deltaTime * 5);
                    camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, 0, deltaTime * 5);
                }

                particleMaterial.uniforms.uTime.value = time;
            }

            composer.render();
        }

        // ========================================
        // Start Experience
        // ========================================
        function startExperience() {
            if (isRunning) return;
            isRunning = true;

            startOverlay.classList.add('hidden');

            // Enable CapCut old film mode for RUNNER intro
            document.body.classList.add('capcut-mode');

            clock.start();

            // Play audio
            audioPlayer.currentTime = 0;
            audioPlayer.play().catch(err => {
                console.warn('Audio playback failed:', err);
                console.log('Please ensure "audio/letdown.mp3" exists in the project folder.');
            });

            console.log('Experience started with audio!');

            LYRIC_SEQUENCE.forEach(lyric => {
                setTimeout(() => executeLyric(lyric), lyric.time * 1000);
            });
        }

        // ========================================
        // Resize
        // ========================================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.resolution.set(window.innerWidth, window.innerHeight);
        }

        // ========================================
        // Initialize
        // ========================================
        init();
    </script>
</body>

</html>