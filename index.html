<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Let Down - Radiohead | Lyric Visualizer</title>
    <meta name="description" content="An immersive 3D lyric visualizer for Radiohead's Let Down">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300&display=swap"
        rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0f;
            font-family: 'Cormorant Garamond', Georgia, serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #lyrics-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: none;
        }

        #lyric-text {
            font-size: clamp(2rem, 5vw, 4rem);
            font-weight: 300;
            font-style: italic;
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            max-width: 80vw;
            line-height: 1.4;
            text-shadow:
                0 0 20px rgba(255, 255, 255, 0.3),
                0 0 40px rgba(100, 150, 255, 0.2);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }

        #lyric-text.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #lyric-text.jitter {
            animation: jitter 0.1s infinite;
        }

        #lyric-text.intense {
            font-weight: 400;
            text-shadow:
                0 0 30px rgba(255, 255, 255, 0.6),
                0 0 60px rgba(100, 150, 255, 0.4),
                0 0 100px rgba(100, 150, 255, 0.2);
        }

        @keyframes jitter {

            0%,
            100% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-1px, 1px);
            }

            50% {
                transform: translate(1px, -1px);
            }

            75% {
                transform: translate(-1px, -1px);
            }
        }

        @keyframes shatter {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateY(200px) scale(0.8);
                opacity: 0;
                filter: blur(10px);
            }
        }

        #flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: white;
            opacity: 0;
            z-index: 15;
            pointer-events: none;
        }

        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            cursor: pointer;
            transition: opacity 1s ease, visibility 1s ease;
        }

        #start-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .start-content {
            text-align: center;
            color: white;
        }

        .start-content h1 {
            font-size: clamp(3rem, 10vw, 8rem);
            font-weight: 300;
            letter-spacing: 0.3em;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 40px rgba(100, 150, 255, 0.3);
            animation: pulse 3s ease-in-out infinite;
        }

        .start-content .artist {
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 300;
            font-style: italic;
            letter-spacing: 0.2em;
            opacity: 0.6;
            margin-bottom: 3rem;
        }

        .start-content .instruction {
            font-size: 1rem;
            font-weight: 400;
            opacity: 0.8;
            animation: fadeInOut 2s ease-in-out infinite;
        }

        .start-content .note {
            font-size: 0.8rem;
            font-weight: 300;
            opacity: 0.4;
            margin-top: 2rem;
            line-height: 1.6;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.8;
                text-shadow: 0 0 40px rgba(100, 150, 255, 0.3);
            }

            50% {
                opacity: 1;
                text-shadow: 0 0 60px rgba(100, 150, 255, 0.5);
            }
        }

        @keyframes fadeInOut {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 0.9;
            }
        }

        .glitch-container {
            position: relative;
        }

        .glitch-container::before,
        .glitch-container::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        .glitch-container::before {
            color: #ff0040;
            animation: glitch-1 0.2s infinite;
            clip-path: polygon(0 0, 100% 0, 100% 35%, 0 35%);
        }

        .glitch-container::after {
            color: #00ffff;
            animation: glitch-2 0.2s infinite;
            clip-path: polygon(0 65%, 100% 65%, 100% 100%, 0 100%);
        }

        @keyframes glitch-1 {

            0%,
            100% {
                transform: translate(0);
            }

            20% {
                transform: translate(-3px, 3px);
            }

            40% {
                transform: translate(3px, -3px);
            }

            60% {
                transform: translate(-3px, -3px);
            }

            80% {
                transform: translate(3px, 3px);
            }
        }

        @keyframes glitch-2 {

            0%,
            100% {
                transform: translate(0);
            }

            20% {
                transform: translate(3px, -3px);
            }

            40% {
                transform: translate(-3px, 3px);
            }

            60% {
                transform: translate(3px, 3px);
            }

            80% {
                transform: translate(-3px, -3px);
            }
        }
    </style>
</head>

<body>
    <div id="canvas-container"></div>

    <div id="lyrics-container">
        <div id="lyric-text"></div>
    </div>

    <div id="flash-overlay"></div>

    <div id="start-overlay">
        <div class="start-content">
            <h1>LET DOWN</h1>
            <p class="artist">Radiohead</p>
            <p class="instruction">Click anywhere to begin</p>
            <p class="note">Best experienced with the song playing<br>Start at 3:30 (climax section)</p>
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- GSAP -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>

    <script>
        // ========================================
        // LET DOWN - Radiohead Lyric Visualizer
        // Self-contained version with simple glow
        // ========================================

        // Configuration
        const CONFIG = {
            particles: {
                count: 12000,
                spread: 150,
                depth: 300,
                baseSize: 3
            },
            states: {
                verse: { speed: 0.4, particleSize: 3 },
                buildup: { speed: 1.0, particleSize: 2.5 },
                climax: { speed: 5.0, particleSize: 1.5 },
                hysterical: { speed: 10.0, particleSize: 0.8 }
            }
        };

        // Global variables
        let scene, camera, renderer;
        let particles, particleGeometry;
        let clock, currentState, targetState;
        let isRunning = false;
        let shakeIntensity = 0;
        let originalCameraY = 0;

        // Lyric sequence
        const LYRIC_SEQUENCE = [
            { time: 0, text: "", action: "start" },
            { time: 2, text: "you know", action: "show", state: "verse" },
            { time: 4, text: "where you are with", action: "show" },
            { time: 7, text: "...", action: "show", state: "buildup" },
            { time: 10, text: "floor collapses", action: "collapse" },
            { time: 12, text: "floating", action: "show" },
            { time: 15, text: "bouncing back", action: "show" },
            { time: 18, text: "and one day", action: "show", state: "climax" },
            { time: 21, text: "I am gonna grow wings", action: "wings" },
            { time: 26, text: "a chemical reaction", action: "noise" },
            { time: 30, text: "hysterical and useless", action: "hysterical", state: "hysterical" },
            { time: 36, text: "...", action: "show" },
            { time: 40, text: "", action: "fadeout" }
        ];

        // DOM Elements
        const lyricElement = document.getElementById('lyric-text');
        const flashOverlay = document.getElementById('flash-overlay');
        const startOverlay = document.getElementById('start-overlay');

        // Initialize
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.003);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            originalCameraY = camera.position.y;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Create particles
            createParticles();

            // Clock and state
            clock = new THREE.Clock();
            currentState = { ...CONFIG.states.verse };
            targetState = { ...CONFIG.states.verse };

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            startOverlay.addEventListener('click', startExperience);

            // Start render loop
            animate();

            console.log('Visualizer initialized successfully!');
        }

        // Create particle system
        function createParticles() {
            const { count, spread, depth } = CONFIG.particles;

            particleGeometry = new THREE.BufferGeometry();

            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const velocities = [];

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;

                // Cylindrical distribution
                const theta = Math.random() * Math.PI * 2;
                const radius = Math.random() * spread;

                positions[i3] = Math.cos(theta) * radius;
                positions[i3 + 1] = Math.sin(theta) * radius;
                positions[i3 + 2] = Math.random() * depth - depth / 2;

                // Color: mix of cool grey, deep blue, white
                const colorChoice = Math.random();
                if (colorChoice < 0.5) {
                    // Cool grey
                    colors[i3] = 0.5;
                    colors[i3 + 1] = 0.56;
                    colors[i3 + 2] = 0.63;
                } else if (colorChoice < 0.85) {
                    // Deep blue
                    colors[i3] = 0.25;
                    colors[i3 + 1] = 0.38;
                    colors[i3 + 2] = 0.63;
                } else {
                    // White accent
                    colors[i3] = 1;
                    colors[i3 + 1] = 1;
                    colors[i3 + 2] = 1;
                }

                sizes[i] = Math.random() * 2 + 1;
                velocities.push(Math.random() * 0.5 + 0.75);
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            particleGeometry.userData = { velocities, sizes };

            // Material with vertex colors
            const material = new THREE.PointsMaterial({
                size: CONFIG.particles.baseSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(particleGeometry, material);
            scene.add(particles);
        }

        // Update particles
        function updateParticles(deltaTime) {
            const positions = particleGeometry.attributes.position.array;
            const { velocities } = particleGeometry.userData;
            const { depth, spread } = CONFIG.particles;

            const speed = currentState.speed;

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const i3 = i * 3;

                // Move towards camera
                positions[i3 + 2] += speed * velocities[i] * deltaTime * 60;

                // Reset if past camera
                if (positions[i3 + 2] > camera.position.z + 10) {
                    positions[i3 + 2] = -depth / 2;
                    const theta = Math.random() * Math.PI * 2;
                    const radius = Math.random() * spread;
                    positions[i3] = Math.cos(theta) * radius;
                    positions[i3 + 1] = Math.sin(theta) * radius;
                }
            }

            particleGeometry.attributes.position.needsUpdate = true;
            particles.material.size = currentState.particleSize;
        }

        // Interpolate state
        function updateState(deltaTime) {
            const lerp = (a, b, t) => a + (b - a) * t;
            const lerpFactor = 1 - Math.pow(0.1, deltaTime);

            currentState.speed = lerp(currentState.speed, targetState.speed, lerpFactor);
            currentState.particleSize = lerp(currentState.particleSize, targetState.particleSize, lerpFactor);
        }

        // Camera shake
        function updateCameraShake() {
            if (shakeIntensity > 0) {
                camera.position.x = (Math.random() - 0.5) * shakeIntensity;
                camera.position.y = originalCameraY + (Math.random() - 0.5) * shakeIntensity;
                camera.rotation.z = (Math.random() - 0.5) * shakeIntensity * 0.05;
                shakeIntensity *= 0.95;

                if (shakeIntensity < 0.01) {
                    shakeIntensity = 0;
                    camera.position.x = 0;
                    camera.rotation.z = 0;
                }
            }
        }

        // Lyric functions
        function showLyric(text, options = {}) {
            lyricElement.textContent = text;
            lyricElement.className = 'visible';

            if (options.jitter) lyricElement.classList.add('jitter');
            if (options.intense) lyricElement.classList.add('intense');
            if (options.glitch) {
                lyricElement.classList.add('glitch-container');
                lyricElement.setAttribute('data-text', text);
            }
        }

        function hideLyric() {
            lyricElement.className = '';
            lyricElement.textContent = '';
        }

        function shatterLyric() {
            lyricElement.style.animation = 'shatter 0.5s forwards';
            setTimeout(() => {
                hideLyric();
                lyricElement.style.animation = '';
            }, 500);
        }

        function flashScreen(intensity, duration) {
            gsap.to(flashOverlay, {
                opacity: intensity,
                duration: duration * 0.3,
                ease: "power2.in",
                onComplete: () => {
                    gsap.to(flashOverlay, {
                        opacity: 0,
                        duration: duration * 0.7,
                        ease: "power2.out"
                    });
                }
            });
        }

        function dropCamera() {
            gsap.to(camera.position, {
                y: originalCameraY - 3,
                duration: 0.3,
                ease: "power2.in",
                onComplete: () => {
                    shakeIntensity = 0.5;
                    gsap.to(camera.position, {
                        y: originalCameraY,
                        duration: 2,
                        ease: "elastic.out(1, 0.5)",
                        onUpdate: () => { originalCameraY = 0; }
                    });
                }
            });
        }

        // Execute lyric actions
        function executeLyricAction(lyric) {
            const { text, action, state } = lyric;

            if (state && CONFIG.states[state]) {
                targetState = { ...CONFIG.states[state] };
            }

            switch (action) {
                case 'start':
                    hideLyric();
                    break;

                case 'show':
                    showLyric(text, { jitter: true });
                    break;

                case 'collapse':
                    showLyric(text, { jitter: true, intense: true });
                    dropCamera();
                    setTimeout(shatterLyric, 800);
                    break;

                case 'wings':
                    showLyric("I am gonna grow wings", { intense: true });
                    flashScreen(0.9, 1.5);
                    break;

                case 'noise':
                    showLyric(text, { jitter: true });
                    shakeIntensity = 0.3;
                    break;

                case 'hysterical':
                    showLyric("hysterical and useless", { glitch: true, intense: true });
                    shakeIntensity = 0.8;
                    // Keep shaking
                    const shakeInterval = setInterval(() => {
                        if (shakeIntensity < 0.1) shakeIntensity = 0.5;
                    }, 500);
                    setTimeout(() => clearInterval(shakeInterval), 6000);
                    break;

                case 'fadeout':
                    hideLyric();
                    targetState = { speed: 0.2, particleSize: 2 };
                    break;
            }
        }

        // Start experience
        function startExperience() {
            if (isRunning) return;
            isRunning = true;

            console.log('Experience started!');
            startOverlay.classList.add('hidden');
            clock.start();

            // Schedule lyrics
            LYRIC_SEQUENCE.forEach(lyric => {
                setTimeout(() => executeLyricAction(lyric), lyric.time * 1000);
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = Math.min(clock.getDelta(), 0.1);

            if (isRunning) {
                updateParticles(deltaTime);
                updateState(deltaTime);
                updateCameraShake();
            }

            renderer.render(scene, camera);
        }

        // Resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize when DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>

</html>